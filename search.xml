<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Netty线程模型]]></title>
    <url>%2F2019%2F06%2F02%2FNetty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Netty Netty 是一款提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 选型 使用简单：API 使用简单，开发门槛低。 功能强大：预置了多种编解码功能，支持多种主流协议。 定制能力强：可以通过 ChannelHandler 对通信框架进行灵活的扩展。 性能高：通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优。 成熟稳定：Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼。 社区活跃：版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入。 案例丰富：经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用 网络服务大部分网络服务有着相同的基本的流程 读取请求 请求解码 处理请求 编码响应 发送响应 BIO / NIOBIO Block-IO ，是一种阻塞 + 同步的通信模式,模式简单,但并发处理能力低，通信耗时，依赖网速。服务器通过一个 Acceptor 线程，负责监听客户端请求和为每个客户端创建一个新的线程进行链路处理。典型的一请求一应答模式。 传统的网络服务设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// clientpublic class BIOClient &#123; private static Integer PORT = 8888; private static String IP_ADDRESS = &quot;127.0.0.1&quot;; public static void main(String[] args) &#123; sendRequest(); &#125; private static void sendRequest() &#123; Socket socket = null; BufferedReader reader = null; PrintWriter writer = null; try &#123; socket = new Socket(IP_ADDRESS, PORT); // Socket 发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信 reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 获取返回内容 writer = new PrintWriter(socket.getOutputStream(), true); writer.println(&quot;hello&quot;); // 向服务器端发送数据 System.out.println( &quot;客户端打印返回数据 : &quot; + reader.readLine()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != reader) &#123; reader.close(); &#125; if (null != socket) &#123; socket.close(); socket = null; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;//serverpublic class BIOServer &#123; private static final Integer PORT = 8888; // 服务器对外的端口号 public static void main(String[] args) &#123; ServerSocket server = null; Socket socket = null; ThreadPoolExecutor executor = null; try &#123; server = new ServerSocket(PORT); // ServerSocket 启动监听端口 System.out.println(&quot;服务器启动.........&quot;); while (true) &#123; // 服务器监听：阻塞，等待Client请求 socket = server.accept(); System.out.println(&quot;server 服务器确认请求 : &quot; + socket); new Thread(new Handler()).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != socket) &#123; socket.close(); socket = null; &#125; if (null != server) &#123; server.close(); server = null; System.out.println(&quot;BIO Server 服务器关闭了！！！！&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; NIO Non-Block IO ，是一种非阻塞 + 同步的通信模式.客户端和服务器之间通过 Channel 通信。NIO 可以在 Channel 进行读写操作。这些 Channel 都会被注册在 Selector 多路复用器上。Selector 通过一个线程不停的轮询这些 Channel 。找出已经准备就绪的 Channel 执行 IO 操作。Buffer，Channel，Selector Buffer ： 缓冲区。NIO的数据操作都是在缓冲区中进行。缓冲区实际上是一个数组。而BIO是将数据直接写入或读取到Stream对象。 Channel ： 通道。NIO可以通过Channel进行数据的读，写和同时读写操作。 Selector ： 多路复用器。NIO编程的基础。多路复用器提供选择已经就绪状态任务的能力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class NIOClient &#123; private final static int PORT = 8888; private final static int BUFFER_SIZE = 1024; private final static String IP_ADDRESS = &quot;127.0.0.1&quot;; // 从代码中可以看出，和传统的IO编程很像，很大的区别在于数据是写入缓冲区 public static void main(String[] args) &#123; sendRequest(); &#125; private static void sendRequest() &#123; // 1.创建连接地址 InetSocketAddress inetSocketAddress = new InetSocketAddress(IP_ADDRESS, PORT); // 2.声明一个连接通道 SocketChannel socketChannel = null; // 3.创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE); try &#123; // 4.打开通道 socketChannel = SocketChannel.open(); // 5.连接服务器 socketChannel.connect(inetSocketAddress); while(true)&#123; // 6.定义一个字节数组，然后使用系统录入功能： byte[] bytes = new byte[BUFFER_SIZE]; // 7.键盘输入数据 System.in.read(bytes); // 8.把数据放到缓冲区中 byteBuffer.put(bytes); // 9.对缓冲区进行复位 byteBuffer.flip(); // 10.写出数据 socketChannel.write(byteBuffer); // 11.清空缓冲区数据 byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != socketChannel) &#123; try &#123; socketChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;public class NIOServer implements Runnable &#123; private final int BUFFER_SIZE = 1024; // 缓冲区大小 private final int PORT = 8888; // 监听的端口 private Selector selector; // 多路复用器，NIO编程的基础，负责管理通道Channel // 缓冲区Buffer，和BIO的一个重要区别（NIO读写数据是在缓冲区中进行，而BIO是通过流的形式） private ByteBuffer readBuffer = ByteBuffer.allocate(BUFFER_SIZE); public ITDragonNIOServer() &#123; startServer(); &#125; private void startServer() &#123; try &#123; // 1.开启多路复用器 selector = Selector.open(); // 2.打开服务器通道(网络读写通道) ServerSocketChannel channel = ServerSocketChannel.open(); // 3.设置服务器通道为非阻塞模式，true为阻塞，false为非阻塞 channel.configureBlocking(false); // 4.绑定端口 channel.socket().bind(new InetSocketAddress(PORT)); // 5.把通道注册到多路复用器上，并监听阻塞事件 /** * SelectionKey.OP_READ : 表示关注读数据就绪事件 * SelectionKey.OP_WRITE : 表示关注写数据就绪事件 * SelectionKey.OP_CONNECT: 表示关注socket channel的连接完成事件 * SelectionKey.OP_ACCEPT : 表示关注server-socket channel的accept事件 */ channel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(&quot;Server start &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; port :&quot; + PORT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 需要一个线程负责Selector的轮询 @Override public void run() &#123; while (true) &#123; try &#123; /** * a.select() 阻塞到至少有一个通道在你注册的事件上就绪 * b.select(long timeOut) 阻塞到至少有一个通道在你注册的事件上就绪或者超时timeOut * c.selectNow() 立即返回。如果没有就绪的通道则返回0 * select方法的返回值表示就绪通道的个数。 */ // 1.多路复用器监听阻塞 selector.select(); // 2.多路复用器已经选择的结果集 Iterator&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys().iterator(); // 3.不停的轮询 while (selectionKeys.hasNext()) &#123; // 4.获取一个选中的key SelectionKey key = selectionKeys.next(); // 5.获取后便将其从容器中移除 selectionKeys.remove(); // 6.只获取有效的key if (!key.isValid())&#123; continue; &#125; // 阻塞状态处理 if (key.isAcceptable())&#123; accept(key); &#125; // 可读状态处理 if (key.isReadable())&#123; read(key); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 设置阻塞，等待Client请求。在传统IO编程中，用的是ServerSocket和Socket。在NIO中采用的ServerSocketChannel和SocketChannel private void accept(SelectionKey selectionKey) &#123; try &#123; // 1.获取通道服务 ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel(); // 2.执行阻塞方法 SocketChannel socketChannel = serverSocketChannel.accept(); // 3.设置服务器通道为非阻塞模式，true为阻塞，false为非阻塞 socketChannel.configureBlocking(false); // 4.把通道注册到多路复用器上，并设置读取标识 socketChannel.register(selector, SelectionKey.OP_READ); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void read(SelectionKey selectionKey) &#123; try &#123; // 1.清空缓冲区数据 readBuffer.clear(); // 2.获取在多路复用器上注册的通道 SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); // 3.读取数据，返回 int count = socketChannel.read(readBuffer); // 4.返回内容为-1 表示没有数据 if (-1 == count) &#123; selectionKey.channel().close(); selectionKey.cancel(); return ; &#125; // 5.有数据则在读取数据前进行复位操作 readBuffer.flip(); // 6.根据缓冲区大小创建一个相应大小的bytes数组，用来获取值 byte[] bytes = new byte[readBuffer.remaining()]; // 7.接收缓冲区数据 readBuffer.get(bytes); // 8.打印获取到的数据 System.out.println(&quot;NIO Server : &quot; + new String(bytes)); // 不能用bytes.toString() &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; new Thread(new ITDragonNIOServer()).start(); &#125; &#125; 可扩展IO的实现方式 一般对于实现可扩展的架构分而治之是最好的方法之一。将处理逻辑划分为更小的任务单元，每一个任务单元当处于可运行状态时都按照非阻塞方式运行，Java NIO提供了基本的实现机制。 基于事件的设计(1) 效率更高 * 需要更少的资源，不需要一个客户端一个线程 * 更少的性能消耗，更少的上下文切换，更少的锁操作 * 由于需要绑定处理逻辑到事件，所以事件分发会比较慢(2) 实现较难 * 需要将处理逻辑拆分成简单的无阻塞的操作 * 需要跟踪服务状态 java.nio(1) Channels : 提供对non-blocking读写（2）Buffers : channel 读写的类数组结构（3）Selectors : channels注册到selector上，当channel有IO Event时触发事件（4）SelectionKeys : 保存IO事件状态的实体 Reactor模式 Reactor向不同的IO事件分发合适的处理器 处理器执行无阻塞的处理逻辑 将处理器绑定到事件 单Reactor单线程模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class Reactor implements Runnable &#123; final Selector selector; final ServerSocketChannel serverSocket; public Reactor(int port) throws IOException &#123; this.selector = Selector.open(); this.serverSocket = ServerSocketChannel.open(); serverSocket.socket().bind(new InetSocketAddress(port)); SelectionKey selectionKey = serverSocket.register(selector, SelectionKey.OP_ACCEPT); selectionKey.attach(new Acceptor()); &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; selector.select(); // blocking Set selected = selector.selectedKeys(); Iterator iterator = selected.iterator(); while(iterator.hasNext())&#123; dispatch((SelectionKey)iterator.next()); &#125; selected.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; void dispatch(SelectionKey selectionKey)&#123; Runnable runnable = (Runnable) selectionKey.attachment(); if(runnable != null)&#123; runnable.run(); &#125; &#125; class Acceptor implements Runnable &#123; public void run() &#123; try &#123; SocketChannel socketChannel = serverSocket.accept(); if(socketChannel != null)&#123; new Handler(selector,socketChannel); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Handler implements Runnable &#123; private static int MAXIN = 1024; private static int MAXOUT = 1024; static final int READINNG = 0, SENDING = 1; int state = READINNG; final SocketChannel socketChannel; final SelectionKey selectionKey; ByteBuffer input = ByteBuffer.allocate(MAXIN); ByteBuffer output = ByteBuffer.allocate(MAXOUT); public Handler(Selector selector, SocketChannel socketChannel) throws IOException &#123; this.socketChannel = socketChannel; this.socketChannel.configureBlocking(false); this.selectionKey = socketChannel.register(selector, SelectionKey.OP_READ); this.selectionKey.attach(this); selectionKey.interestOps(SelectionKey.OP_READ); selector.wakeup(); &#125; boolean inputIsComplete()&#123; return false; &#125; boolean outputIsComplete()&#123; return false; &#125; void process()&#123; &#125; void read()&#123; try &#123; socketChannel.read(input); if(inputIsComplete())&#123; state = SENDING; selectionKey.interestOps(SelectionKey.OP_WRITE); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; void write() throws IOException &#123; socketChannel.write(output); if(outputIsComplete())&#123; selectionKey.cancel(); &#125; &#125; @Override public void run() &#123; if(state == READINNG)&#123; read(); &#125; if(state == SENDING)&#123; try &#123; write(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 多工作线程模型 策略性地添加线程以实现可伸缩性 主要适用于多处理器 单Reactor多工作线程模型(1)反应堆应迅速触发处理程序 处理器处理减慢反应堆速度(2)将非io处理卸载给其他线程 卸载非io处理以加速Reactor线程，类似于POSA2 Proactor的设计 比将计算绑定处理重新处理为事件驱动的形式更简单，还是纯非阻塞计算，足够的处理来抵消开销 但是很难与IO重叠处理， 最好能在第一时间将所有输入读入缓冲区 使用线程池可以调优和控制，通常需要比客户机少得多的线程 public class WorkerThreadsHandler implements Runnable { public static final int READING = 0, WRITING = 1; int state; final SocketChannel socketChannel; final SelectionKey selectionKey; //多线程处理业务逻辑 ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); public WorkerThreadsHandler(SocketChannel socketChannel, Selector selector) throws IOException { this.socketChannel = socketChannel; socketChannel.configureBlocking(false); this.selectionKey = socketChannel.register(selector, SelectionKey.OP_READ); selectionKey.attach(this); } @Override public void run() { if (state == READING) { read(); } else if (state == WRITING) { write(); } } private void read(){ executorService.submit(() -&gt; process()); selectionKey.interestOps(SelectionKey.OP_WRITE); this.state = WRITING; } private void write(){ executorService.submit(() -&gt; process()); selectionKey.interestOps(SelectionKey.OP_READ); this.state = READING; } void process(){ }} 多Reactor多线程模型(1)反应堆线程可以饱和做IO(2)将负荷分配给其他反应堆 负载平衡以匹配CPU和IO速率 Using Reactor Pools Use to match CPU and IO rates Static or dynamic construction， Each with own Selector, Thread, dispatch loop Main acceptor distributes to other reactors 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class Reactor implements Runnable &#123; final Selector selector; final ServerSocketChannel serverSocket; public Reactor(int port) throws IOException &#123; this.selector = Selector.open(); this.serverSocket = ServerSocketChannel.open(); serverSocket.socket().bind(new InetSocketAddress(port)); SelectionKey selectionKey = serverSocket.register(selector, SelectionKey.OP_ACCEPT); selectionKey.attach(new Acceptor()); &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; selector.select(); // blocking Set selected = selector.selectedKeys(); Iterator iterator = selected.iterator(); while(iterator.hasNext())&#123; dispatch((SelectionKey)iterator.next()); &#125; selected.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; void dispatch(SelectionKey selectionKey)&#123; Runnable runnable = (Runnable) selectionKey.attachment(); if(runnable != null)&#123; runnable.run(); &#125; &#125; class Acceptor implements Runnable &#123; int workCount = Runtime.getRuntime().availableProcessors(); SubReactor[] workThreadHandlers = new SubReactor[workCount]; volatile int nextHandler = 0; public Acceptor() &#123; nextHandler = 0; for (int i = 0; i &lt; workThreadHandlers.length; i++) &#123; try &#123; workThreadHandlers[i] = new SubReactor(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; @Override public void run() &#123; try &#123; SocketChannel socketChannel = serverSocket.accept(); if(socketChannel != null)&#123; synchronized (socketChannel)&#123; // 顺序获取SubReactor，然后注册channel SubReactor work = workThreadHandlers[nextHandler]; work.registerChannel(socketChannel); nextHandler++; if (nextHandler &gt;= workThreadHandlers.length) &#123; nextHandler = 0; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class SubReactor implements Runnable&#123; final Selector selector; int workCount = Runtime.getRuntime().availableProcessors(); ExecutorService executorService = Executors.newFixedThreadPool(workCount); public SubReactor() throws IOException &#123; this.selector = SelectorProvider.provider().openSelector(); &#125; public void registerChannel(SocketChannel sc) throws Exception &#123; sc.register(selector, SelectionKey.OP_READ | SelectionKey.OP_CONNECT); &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; selector.select(); // blocking Set selected = selector.selectedKeys(); Iterator iterator = selected.iterator(); while(iterator.hasNext())&#123; SelectionKey selectionKey = (SelectionKey)iterator.next(); iterator.remove(); if(selectionKey.isReadable())&#123; read(); &#125; if(selectionKey.isWritable())&#123; write(); &#125; &#125; selected.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void read()&#123; executorService.submit(() -&gt; process()); &#125; private void write()&#123; executorService.submit(() -&gt; process()); &#125; void process()&#123; &#125;&#125; Netty是怎样实现高性能的？1. 线程模型 采用异步非阻塞的 I/O 类库，基于 Reactor 模式实现，解决了传统同步阻塞 I/O 模式下服务端无法平滑处理客户端线性增长的问题。 2. 内存池3. 零拷贝4. 协议支持5. JNI]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动客户端接入互联网]]></title>
    <url>%2F2019%2F06%2F01%2F%E7%A7%BB%E5%8A%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%85%A5%E4%BA%92%E8%81%94%E7%BD%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello EveryOne]]></title>
    <url>%2F2019%2F05%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to here.]]></content>
  </entry>
</search>
