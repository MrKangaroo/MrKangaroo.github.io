<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="MrKangaroo&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MrKangaroo&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MrKangaroo&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>MrKangaroo's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MrKangaroo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/首页" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/归档" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/分类" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/标签" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/关于" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/搜索" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            搜索
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/公益404" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/Netty线程模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mrkangaroo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MrKangaroo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/02/Netty线程模型/" itemprop="url">Netty线程模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-02T10:36:44+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><blockquote>
<p>Netty 是一款提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p>
</blockquote>
<h5 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h5><ul>
<li>使用简单：API 使用简单，开发门槛低。</li>
<li>功能强大：预置了多种编解码功能，支持多种主流协议。</li>
<li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活的扩展。</li>
<li>性能高：通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优。</li>
<li>成熟稳定：Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼。</li>
<li>社区活跃：版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入。</li>
<li>案例丰富：经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用</li>
</ul>
<h4 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h4><p>大部分网络服务有着相同的基本的流程</p>
<ul>
<li>读取请求</li>
<li>请求解码</li>
<li>处理请求</li>
<li>编码响应</li>
<li>发送响应</li>
</ul>
<h4 id="BIO-NIO"><a href="#BIO-NIO" class="headerlink" title="BIO / NIO"></a>BIO / NIO</h4><h5 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h5><blockquote>
<p>Block-IO ，是一种阻塞 + 同步的通信模式,模式简单,但并发处理能力低，通信耗时，依赖网速。服务器通过一个 Acceptor 线程，负责监听客户端请求和为每个客户端创建一个新的线程进行链路处理。典型的一请求一应答模式。</p>
</blockquote>
<h5 id="传统的网络服务设计"><a href="#传统的网络服务设计" class="headerlink" title="传统的网络服务设计"></a>传统的网络服务设计</h5><p><img src="/2019/06/02/Netty线程模型/bio.jpg" alt="bio"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// client</span><br><span class="line">public class BIOClient &#123;</span><br><span class="line">	</span><br><span class="line">	  private static Integer PORT = 8888;  </span><br><span class="line">    private static String IP_ADDRESS = &quot;127.0.0.1&quot;;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">            sendRequest();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    private static void sendRequest() &#123;  </span><br><span class="line">        Socket socket = null;  </span><br><span class="line">        BufferedReader reader = null;  </span><br><span class="line">        PrintWriter writer = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            socket = new Socket(IP_ADDRESS, PORT); // Socket 发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信  </span><br><span class="line">            reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 获取返回内容  </span><br><span class="line">            writer = new PrintWriter(socket.getOutputStream(), true);  </span><br><span class="line">            writer.println(&quot;hello&quot;); // 向服务器端发送数据  </span><br><span class="line">            System.out.println( &quot;客户端打印返回数据 : &quot; + reader.readLine());  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                if (null != reader) &#123;  </span><br><span class="line">                    reader.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (null != socket) &#123;  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                    socket = null;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; catch (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//server</span><br><span class="line">public class BIOServer &#123;</span><br><span class="line">	</span><br><span class="line">	  private static final Integer PORT = 8888; // 服务器对外的端口号  </span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        ServerSocket server = null;  </span><br><span class="line">        Socket socket = null;  </span><br><span class="line">        ThreadPoolExecutor executor = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            server = new ServerSocket(PORT); // ServerSocket 启动监听端口  </span><br><span class="line">            System.out.println(&quot;服务器启动.........&quot;);  </span><br><span class="line">            while (true) &#123; </span><br><span class="line">                // 服务器监听：阻塞，等待Client请求 </span><br><span class="line">                socket = server.accept(); </span><br><span class="line">                System.out.println(&quot;server 服务器确认请求 : &quot; + socket); </span><br><span class="line">                new Thread(new Handler()).start(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                if (null != socket) &#123;  </span><br><span class="line">                  socket.close(); </span><br><span class="line">                  socket = null;</span><br><span class="line">                &#125;  </span><br><span class="line">                if (null != server) &#123;  </span><br><span class="line">                    server.close();  </span><br><span class="line">                    server = null;  </span><br><span class="line">                    System.out.println(&quot;BIO Server 服务器关闭了！！！！&quot;);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; catch (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h5><blockquote>
<p>Non-Block IO ，是一种非阻塞 + 同步的通信模式.客户端和服务器之间通过 Channel 通信。NIO 可以在 Channel 进行读写操作。这些 Channel 都会被注册在 Selector 多路复用器上。Selector 通过一个线程不停的轮询这些 Channel 。找出已经准备就绪的 Channel 执行 IO 操作。<br>Buffer，Channel，Selector<br> Buffer   ： 缓冲区。NIO的数据操作都是在缓冲区中进行。缓冲区实际上是一个数组。而BIO是将数据直接写入或读取到Stream对象。<br> Channel  ：  通道。NIO可以通过Channel进行数据的读，写和同时读写操作。<br> Selector ：  多路复用器。NIO编程的基础。多路复用器提供选择已经就绪状态任务的能力</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">public class NIOClient &#123;</span><br><span class="line">	</span><br><span class="line">	  private final static int PORT = 8888;  </span><br><span class="line">    private final static int BUFFER_SIZE = 1024;  </span><br><span class="line">    private final static String IP_ADDRESS = &quot;127.0.0.1&quot;;  </span><br><span class="line">  </span><br><span class="line">    // 从代码中可以看出，和传统的IO编程很像，很大的区别在于数据是写入缓冲区  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">    	sendRequest();</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    private static void sendRequest() &#123;</span><br><span class="line">    	// 1.创建连接地址  </span><br><span class="line">        InetSocketAddress inetSocketAddress = new InetSocketAddress(IP_ADDRESS, PORT);  </span><br><span class="line">        // 2.声明一个连接通道  </span><br><span class="line">        SocketChannel socketChannel = null;  </span><br><span class="line">        // 3.创建一个缓冲区  </span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);  </span><br><span class="line">        try &#123;  </span><br><span class="line">            // 4.打开通道  </span><br><span class="line">            socketChannel = SocketChannel.open();  </span><br><span class="line">            // 5.连接服务器  </span><br><span class="line">            socketChannel.connect(inetSocketAddress);  </span><br><span class="line">            while(true)&#123;  </span><br><span class="line">                // 6.定义一个字节数组，然后使用系统录入功能：  </span><br><span class="line">                byte[] bytes = new byte[BUFFER_SIZE];  </span><br><span class="line">                // 7.键盘输入数据  </span><br><span class="line">                System.in.read(bytes);  </span><br><span class="line">                // 8.把数据放到缓冲区中  </span><br><span class="line">                byteBuffer.put(bytes);  </span><br><span class="line">                // 9.对缓冲区进行复位  </span><br><span class="line">                byteBuffer.flip();  </span><br><span class="line">                // 10.写出数据  </span><br><span class="line">                socketChannel.write(byteBuffer);  </span><br><span class="line">                // 11.清空缓冲区数据  </span><br><span class="line">                byteBuffer.clear();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            if (null != socketChannel) &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    socketChannel.close();  </span><br><span class="line">                &#125; catch (IOException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class NIOServer implements Runnable &#123;  </span><br><span class="line">    </span><br><span class="line">  private final int BUFFER_SIZE = 1024; // 缓冲区大小  </span><br><span class="line">  private final int PORT = 8888; 		// 监听的端口  </span><br><span class="line">  private Selector selector;  			// 多路复用器，NIO编程的基础，负责管理通道Channel </span><br><span class="line">  // 缓冲区Buffer，和BIO的一个重要区别（NIO读写数据是在缓冲区中进行，而BIO是通过流的形式）  </span><br><span class="line">  private ByteBuffer readBuffer = ByteBuffer.allocate(BUFFER_SIZE);  </span><br><span class="line">    </span><br><span class="line">  public ITDragonNIOServer() &#123;  </span><br><span class="line">      startServer();  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  private void startServer() &#123;  </span><br><span class="line">      try &#123;  </span><br><span class="line">          // 1.开启多路复用器  </span><br><span class="line">          selector = Selector.open();  </span><br><span class="line">          // 2.打开服务器通道(网络读写通道)  </span><br><span class="line">          ServerSocketChannel channel = ServerSocketChannel.open();  </span><br><span class="line">          // 3.设置服务器通道为非阻塞模式，true为阻塞，false为非阻塞  </span><br><span class="line">          channel.configureBlocking(false);  </span><br><span class="line">          // 4.绑定端口  </span><br><span class="line">          channel.socket().bind(new InetSocketAddress(PORT));  </span><br><span class="line">          // 5.把通道注册到多路复用器上，并监听阻塞事件  </span><br><span class="line">          /** </span><br><span class="line">           * SelectionKey.OP_READ 	: 表示关注读数据就绪事件  </span><br><span class="line">           * SelectionKey.OP_WRITE 	: 表示关注写数据就绪事件  </span><br><span class="line">           * SelectionKey.OP_CONNECT: 表示关注socket channel的连接完成事件  </span><br><span class="line">           * SelectionKey.OP_ACCEPT : 表示关注server-socket channel的accept事件  </span><br><span class="line">           */  </span><br><span class="line">          channel.register(selector, SelectionKey.OP_ACCEPT);  </span><br><span class="line">          System.out.println(&quot;Server start &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; port :&quot; + PORT);  </span><br><span class="line">      &#125; catch (IOException e) &#123;  </span><br><span class="line">          e.printStackTrace();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  // 需要一个线程负责Selector的轮询  </span><br><span class="line">  @Override  </span><br><span class="line">  public void run() &#123;  </span><br><span class="line">      while (true) &#123;  </span><br><span class="line">          try &#123;  </span><br><span class="line">              /** </span><br><span class="line">               * a.select() 阻塞到至少有一个通道在你注册的事件上就绪  </span><br><span class="line">               * b.select(long timeOut) 阻塞到至少有一个通道在你注册的事件上就绪或者超时timeOut </span><br><span class="line">               * c.selectNow() 立即返回。如果没有就绪的通道则返回0  </span><br><span class="line">               * select方法的返回值表示就绪通道的个数。 </span><br><span class="line">               */  </span><br><span class="line">              // 1.多路复用器监听阻塞  </span><br><span class="line">              selector.select();  </span><br><span class="line">              // 2.多路复用器已经选择的结果集  </span><br><span class="line">              Iterator&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys().iterator();  </span><br><span class="line">              // 3.不停的轮询  </span><br><span class="line">              while (selectionKeys.hasNext()) &#123;  </span><br><span class="line">                  // 4.获取一个选中的key  </span><br><span class="line">                  SelectionKey key = selectionKeys.next();  </span><br><span class="line">                  // 5.获取后便将其从容器中移除  </span><br><span class="line">                  selectionKeys.remove();  </span><br><span class="line">                  // 6.只获取有效的key  </span><br><span class="line">                  if (!key.isValid())&#123;  </span><br><span class="line">                      continue;  </span><br><span class="line">                  &#125;  </span><br><span class="line">                  // 阻塞状态处理  </span><br><span class="line">                  if (key.isAcceptable())&#123;  </span><br><span class="line">                      accept(key);  </span><br><span class="line">                  &#125;  </span><br><span class="line">                  // 可读状态处理  </span><br><span class="line">                  if (key.isReadable())&#123;  </span><br><span class="line">                      read(key);  </span><br><span class="line">                  &#125;  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125; catch (IOException e) &#123;  </span><br><span class="line">              e.printStackTrace();  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  // 设置阻塞，等待Client请求。在传统IO编程中，用的是ServerSocket和Socket。在NIO中采用的ServerSocketChannel和SocketChannel  </span><br><span class="line">  private void accept(SelectionKey selectionKey) &#123;  </span><br><span class="line">      try &#123;  </span><br><span class="line">          // 1.获取通道服务  </span><br><span class="line">          ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();  </span><br><span class="line">          // 2.执行阻塞方法  </span><br><span class="line">          SocketChannel socketChannel = serverSocketChannel.accept();  </span><br><span class="line">          // 3.设置服务器通道为非阻塞模式，true为阻塞，false为非阻塞  </span><br><span class="line">          socketChannel.configureBlocking(false);  </span><br><span class="line">          // 4.把通道注册到多路复用器上，并设置读取标识  </span><br><span class="line">          socketChannel.register(selector, SelectionKey.OP_READ);  </span><br><span class="line">      &#125; catch (IOException e) &#123;  </span><br><span class="line">          e.printStackTrace();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  private void read(SelectionKey selectionKey) &#123;  </span><br><span class="line">      try &#123;  </span><br><span class="line">          // 1.清空缓冲区数据  </span><br><span class="line">          readBuffer.clear();  </span><br><span class="line">          // 2.获取在多路复用器上注册的通道  </span><br><span class="line">          SocketChannel socketChannel = (SocketChannel) selectionKey.channel();  </span><br><span class="line">          // 3.读取数据，返回  </span><br><span class="line">          int count = socketChannel.read(readBuffer);  </span><br><span class="line">          // 4.返回内容为-1 表示没有数据  </span><br><span class="line">          if (-1 == count) &#123;  </span><br><span class="line">              selectionKey.channel().close();  </span><br><span class="line">              selectionKey.cancel();  </span><br><span class="line">              return ;  </span><br><span class="line">          &#125;  </span><br><span class="line">          // 5.有数据则在读取数据前进行复位操作  </span><br><span class="line">          readBuffer.flip();  </span><br><span class="line">          // 6.根据缓冲区大小创建一个相应大小的bytes数组，用来获取值  </span><br><span class="line">          byte[] bytes = new byte[readBuffer.remaining()];  </span><br><span class="line">          // 7.接收缓冲区数据  </span><br><span class="line">          readBuffer.get(bytes);  </span><br><span class="line">          // 8.打印获取到的数据  </span><br><span class="line">          System.out.println(&quot;NIO Server : &quot; + new String(bytes)); // 不能用bytes.toString()  </span><br><span class="line">      &#125; catch (IOException e) &#123;  </span><br><span class="line">          e.printStackTrace();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  public static void main(String[] args) &#123;  </span><br><span class="line">      new Thread(new ITDragonNIOServer()).start();  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可扩展IO的实现方式"><a href="#可扩展IO的实现方式" class="headerlink" title="可扩展IO的实现方式"></a>可扩展IO的实现方式</h4><ol>
<li><p>一般对于实现可扩展的架构分而治之是最好的方法之一。将处理逻辑划分为更小的任务单元，每一个任务单元当处于可运行状态时都按照非阻塞方式运行，Java NIO提供了基本的实现机制。</p>
</li>
<li><p>基于事件的设计<br>(1) 效率更高</p>
<pre><code>* 需要更少的资源，不需要一个客户端一个线程
* 更少的性能消耗，更少的上下文切换，更少的锁操作
* 由于需要绑定处理逻辑到事件，所以事件分发会比较慢</code></pre><p>(2) 实现较难</p>
<pre><code>* 需要将处理逻辑拆分成简单的无阻塞的操作
* 需要跟踪服务状态</code></pre></li>
<li><p>java.nio<br>(1) Channels : 提供对non-blocking读写<br>（2）Buffers : channel 读写的类数组结构<br>（3）Selectors : channels注册到selector上，当channel有IO Event时触发事件<br>（4）SelectionKeys : 保存IO事件状态的实体 </p>
</li>
</ol>
<h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h4><blockquote>
<ol>
<li>Reactor向不同的IO事件分发合适的处理器 </li>
<li>处理器执行无阻塞的处理逻辑</li>
<li>将处理器绑定到事件</li>
</ol>
</blockquote>
<h5 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h5><p><img src="/2019/06/02/Netty线程模型/reactor-single.jpg" alt="单Reactor单线程模型"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">public class Reactor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    final Selector selector;</span><br><span class="line"></span><br><span class="line">    final ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">    public Reactor(int port) throws IOException &#123;</span><br><span class="line">        this.selector = Selector.open();</span><br><span class="line">        this.serverSocket = ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(new InetSocketAddress(port));</span><br><span class="line">        SelectionKey selectionKey = serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        selectionKey.attach(new Acceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select(); // blocking</span><br><span class="line">                Set selected = selector.selectedKeys();</span><br><span class="line">                Iterator iterator = selected.iterator();</span><br><span class="line">                while(iterator.hasNext())&#123;</span><br><span class="line">                    dispatch((SelectionKey)iterator.next());</span><br><span class="line">                &#125;</span><br><span class="line">                selected.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatch(SelectionKey selectionKey)&#123;</span><br><span class="line">       Runnable runnable = (Runnable) selectionKey.attachment();</span><br><span class="line">       if(runnable != null)&#123;</span><br><span class="line">           runnable.run();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Acceptor implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                SocketChannel socketChannel = serverSocket.accept();</span><br><span class="line">                if(socketChannel != null)&#123;</span><br><span class="line">                    new Handler(selector,socketChannel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Handler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int MAXIN = 1024;</span><br><span class="line">    private static int MAXOUT = 1024;</span><br><span class="line"></span><br><span class="line">    static final int READINNG = 0, SENDING = 1;</span><br><span class="line">    int state = READINNG;</span><br><span class="line"></span><br><span class="line">    final SocketChannel socketChannel;</span><br><span class="line">    final SelectionKey selectionKey;</span><br><span class="line">    ByteBuffer input = ByteBuffer.allocate(MAXIN);</span><br><span class="line">    ByteBuffer output = ByteBuffer.allocate(MAXOUT);</span><br><span class="line"></span><br><span class="line">    public Handler(Selector selector, SocketChannel socketChannel) throws IOException &#123;</span><br><span class="line">        this.socketChannel = socketChannel;</span><br><span class="line">        this.socketChannel.configureBlocking(false);</span><br><span class="line">        this.selectionKey = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        this.selectionKey.attach(this);</span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean inputIsComplete()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean outputIsComplete()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void process()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void read()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            socketChannel.read(input);</span><br><span class="line">            if(inputIsComplete())&#123;</span><br><span class="line">                state = SENDING;</span><br><span class="line">                selectionKey.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void write() throws IOException &#123;</span><br><span class="line">        socketChannel.write(output);</span><br><span class="line">        if(outputIsComplete())&#123;</span><br><span class="line">            selectionKey.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if(state == READINNG)&#123;</span><br><span class="line">            read();</span><br><span class="line">        &#125;</span><br><span class="line">        if(state == SENDING)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多工作线程模型"><a href="#多工作线程模型" class="headerlink" title="多工作线程模型"></a>多工作线程模型</h5><ol>
<li><p>策略性地添加线程以实现可伸缩性<br> 主要适用于多处理器</p>
</li>
<li><p>单Reactor多工作线程模型<br>(1)反应堆应迅速触发处理程序<br>   处理器处理减慢反应堆速度<br>(2)将非io处理卸载给其他线程</p>
</li>
</ol>
<ul>
<li>卸载非io处理以加速Reactor线程，类似于POSA2 Proactor的设计</li>
<li>比将计算绑定处理重新处理为事件驱动的形式更简单，还是纯非阻塞计算，足够的处理来抵消开销</li>
<li>但是很难与IO重叠处理， 最好能在第一时间将所有输入读入缓冲区</li>
<li>使用线程池可以调优和控制，通常需要比客户机少得多的线程</li>
</ul>
<p><img src="/2019/06/02/Netty线程模型/reactor-workers.jpg" alt="多工作线程模型"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class WorkerThreadsHandler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public static final int READING = 0, WRITING = 1;</span><br><span class="line">    int state;</span><br><span class="line">    final SocketChannel socketChannel;</span><br><span class="line">    final SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    //多线程处理业务逻辑</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    public WorkerThreadsHandler(SocketChannel socketChannel, Selector selector) throws IOException &#123;</span><br><span class="line">        this.socketChannel = socketChannel;</span><br><span class="line">        socketChannel.configureBlocking(false);</span><br><span class="line">        this.selectionKey = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        selectionKey.attach(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (state == READING) &#123;</span><br><span class="line">            read();</span><br><span class="line">        &#125; else if (state == WRITING) &#123;</span><br><span class="line">            write();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void read()&#123;</span><br><span class="line">        executorService.submit(() -&gt; process());</span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">        this.state = WRITING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void write()&#123;</span><br><span class="line">        executorService.submit(() -&gt; process());</span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        this.state = READING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void process()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>多Reactor多线程模型<br>(1)反应堆线程可以饱和做IO<br>(2)将负荷分配给其他反应堆<br> 负载平衡以匹配CPU和IO速率</li>
</ol>
<ul>
<li>Using Reactor Pools</li>
<li>Use to match CPU and IO rates</li>
<li>Static or dynamic construction， Each with own Selector, Thread, dispatch loop </li>
<li>Main acceptor distributes to other reactors</li>
</ul>
<p><img src="/2019/06/02/Netty线程模型/reactor-multi.jpg" alt="多Reactor多线程模型"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">public class Reactor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    final Selector selector;</span><br><span class="line"></span><br><span class="line">    final ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">    public Reactor(int port) throws IOException &#123;</span><br><span class="line">        this.selector = Selector.open();</span><br><span class="line">        this.serverSocket = ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(new InetSocketAddress(port));</span><br><span class="line">        SelectionKey selectionKey = serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        selectionKey.attach(new Acceptor());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select(); // blocking</span><br><span class="line">                Set selected = selector.selectedKeys();</span><br><span class="line">                Iterator iterator = selected.iterator();</span><br><span class="line">                while(iterator.hasNext())&#123;</span><br><span class="line">                    dispatch((SelectionKey)iterator.next());</span><br><span class="line">                &#125;</span><br><span class="line">                selected.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatch(SelectionKey selectionKey)&#123;</span><br><span class="line">       Runnable runnable = (Runnable) selectionKey.attachment();</span><br><span class="line">       if(runnable != null)&#123;</span><br><span class="line">           runnable.run();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Acceptor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        int workCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        SubReactor[] workThreadHandlers = new SubReactor[workCount];</span><br><span class="line">        volatile int nextHandler = 0;</span><br><span class="line"></span><br><span class="line">        public Acceptor() &#123;</span><br><span class="line">            nextHandler = 0;</span><br><span class="line">            for (int i = 0; i &lt; workThreadHandlers.length; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    workThreadHandlers[i] = new SubReactor();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                SocketChannel socketChannel = serverSocket.accept();</span><br><span class="line">                if(socketChannel != null)&#123;</span><br><span class="line">                    synchronized (socketChannel)&#123;</span><br><span class="line">                        // 顺序获取SubReactor，然后注册channel</span><br><span class="line">                        SubReactor work = workThreadHandlers[nextHandler];</span><br><span class="line">                        work.registerChannel(socketChannel);</span><br><span class="line">                        nextHandler++;</span><br><span class="line">                        if (nextHandler &gt;= workThreadHandlers.length) &#123;</span><br><span class="line">                            nextHandler = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SubReactor implements  Runnable&#123;</span><br><span class="line">    final Selector selector;</span><br><span class="line"></span><br><span class="line">    int workCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(workCount);</span><br><span class="line"></span><br><span class="line">    public SubReactor() throws IOException &#123;</span><br><span class="line">        this.selector = SelectorProvider.provider().openSelector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerChannel(SocketChannel sc) throws Exception &#123;</span><br><span class="line">        sc.register(selector, SelectionKey.OP_READ | SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select(); // blocking</span><br><span class="line">                Set selected = selector.selectedKeys();</span><br><span class="line">                Iterator iterator = selected.iterator();</span><br><span class="line">                while(iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey selectionKey = (SelectionKey)iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    if(selectionKey.isReadable())&#123;</span><br><span class="line">                        read();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(selectionKey.isWritable())&#123;</span><br><span class="line">                        write();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                selected.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void read()&#123;</span><br><span class="line">        executorService.submit(() -&gt; process());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void write()&#123;</span><br><span class="line">        executorService.submit(() -&gt; process());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void process()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Netty是怎样实现高性能的？"><a href="#Netty是怎样实现高性能的？" class="headerlink" title="Netty是怎样实现高性能的？"></a>Netty是怎样实现高性能的？</h4><h5 id="1-线程模型"><a href="#1-线程模型" class="headerlink" title="1. 线程模型"></a>1. 线程模型</h5><blockquote>
<p>采用异步非阻塞的 I/O 类库，基于 Reactor 模式实现，解决了传统同步阻塞 I/O 模式下服务端无法平滑处理客户端线性增长的问题。</p>
</blockquote>
<h5 id="2-内存池"><a href="#2-内存池" class="headerlink" title="2. 内存池"></a>2. 内存池</h5><h5 id="3-零拷贝"><a href="#3-零拷贝" class="headerlink" title="3. 零拷贝"></a>3. 零拷贝</h5><h5 id="4-协议支持"><a href="#4-协议支持" class="headerlink" title="4. 协议支持"></a>4. 协议支持</h5><h5 id="5-JNI"><a href="#5-JNI" class="headerlink" title="5. JNI"></a>5. JNI</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/移动客户端接入互联网/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mrkangaroo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MrKangaroo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/移动客户端接入互联网/" itemprop="url">移动客户端接入互联网</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T12:29:44+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/31/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mrkangaroo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MrKangaroo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/31/hello-world/" itemprop="url">Hello EveryOne</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-31T10:15:58+08:00">
                2019-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to here.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mrkangaroo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/归档">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mrkangaroo</span>

  
</div>
<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>

-->


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
